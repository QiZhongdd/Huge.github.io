---
layout: post
title: 宏观视角下的浏览器（3）
subtitle: 输入一个URL会发生什么
date: 2020-12-09
author: Qi
header-img: img/404-bg.jpg
catalog: true
tags:
  - 浏览器
---

# 从浏览器的进程看输入URL发生了什么

- 浏览器进程接受到url后会处理输入的信息然后发送给网络进程
- 网络进程收到url后便会发起url请求
- 收到响应后网络进程收到响应头数据后解析并传给浏览器进程
- 浏览器进程收到网络进程的响应头数据后，发送“提交导航”信号到渲染进程
- 渲染进程收到“提交导航消息后”开始接受html数据，接受数据的方式是直接与网络进程建立数据管道
- 最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程‘已经准备好解析数据了“
- 浏览器进程收到渲染进程的”确认提交信号“后开始，开始移除旧的文档，显示新的界面

**用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。**

  ![Image text](/img/92d73c75308e50d5c06ad44612bcb45d.webp)

# 从输入 URL 到页面展示

**用户输入**

用户在输入后会判断输入的内容时搜索的内容还是请求的URL
- 如果是搜索的内容，那么地址栏会使用默认的搜索引擎，来合成带关键字的URL
- 如果判断输入的为符合规则的URL，那么地址栏会根据规则把这段内容加上协议合成完整的URL

当用户输入关键字并回车后意味着当前页面会被替换成新的界面，这个时候会给当前页面执行beforeUnload的事件机会，beforeUnload事件允许页面在退出时做一些数据清除的操作，还可以询问用户是否需要离开页面，比如当前页面还有未提交的表单，用户可以通过beforUnload事件取消导航，让浏览器不在进行后面的工作

**请求过程**

浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接

- 构建请求

浏览器构建请求行信息后准备发送网络请求

```

GET /index.html HTTP1.1

```

- 查找缓存

在浏览器发起请求之前会浏览器会在浏览器缓存中查找是否有要请求的文件，如果有缓存那么会拦截该请求，返回该资源的副本，如果缓存查找失败，那么就会进入网络请求。

这里说的缓存是指DNS缓存和http缓存，DNS 缓存主要就是在浏览器本地把对应的 IP 和域名关联起来，http缓存可以参考 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching


- 准备IP地址和端口

IP地址通过DNS解析获取，DNS解析首先会从缓存中查看是否解析过，如果没有那么会从本地操作系统的host中是否有映射，然后查看本地DNS服务器，如果本地的DNS服务器没有，本地的DNS请求根域名的DNS服务器，跟域名服务器会返回主域名服务器所在的IP，本地的DNS再根据主域名IP请求对应的名称服务器的IP地址，然后在请求对应的名称服务器根据映射表获取到目标的IP地址。

http的默认端口号是80，https的默认端口是443

如果协议是https，那么在这个过程还需要建立TLS连接，查看 https://juejin.cn/post/6906126429381984264

- 等待 TCP 队列

端口号和IP地址准备好了后还不能马上建立连接，Chrome有个机制，同一个域名下最大只能建立6个TCP连接，如果在同一个域名下发生10个请求，那么剩余的4个会进入等待状态，只有少于六个请求时才会建立TCP链接

- 建立TCP链接

TCP的连接主要是通过三次握手机制。建立连接时，客户端发送syn包（seq=j）到服务器，并进入SYN_SENT状态（半连接），等待服务器确认； 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN+ACK包，此时服务器进入SYN_RECV状态（半连接）。客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手，建立连接。

- 发送http请求

建立连接后，浏览器会向服务端发送请求行、请求头、请求体。

![Image text](/img/b8993c73f7b60feb9b8bd147545c47d7.webp)

**服务器端处理 HTTP 请求流程**

- 返回请求

一旦服务器处理请求完毕，那么首先会返回响应头，响应头包括协议版本和状态码，然后返回响应头和响应体。

![Image text](/img/3e30476a4bbda49fd7cd4fd0ea09f076.webp)

- 断开连接

一旦服务器发送数据完毕后就会断开连接，断开连接采用四次挥手的机制。
- - 断开连接时，主动方会向被动方发送一个带有FIN附加标记的报文段（FIN表示英文finish，主动方进入半关闭状态（FIN_WAIT_1）。
- - 被动方收到FIN标记的报文段后，不会马上断开连接，首先会发送一个ACK包给客户端，同时通知自己的应用程序对方要关闭连接了，进入close_wait状态。
- - 被动方向客户端发送一个带FIN的报文，进入close状态。
- - 主动方收到被动方发起的FIN报头后，进入time_wait状态，等待2MSL的时间进入到closed状态，释放套接字资源。释放前向被动方发起一个ack包，表示彻底释放。

如果浏览器或者服务器在其头信息中加入了：

```
Connection:Keep-Alive

```
那么TCP会保持连接，可以省去下次请求重新连接的时间，提升资源的加载速度

- 重定向

如果状态码返回的是301或者302，那么会进行重定向


![Image text](/img/1b49976aca2c700883d48d927f48986c.webp)


**渲染模块**

- 构建DOM树

获取到html文本后，浏览器的html解析器将html解析成DOM树。DOM树跟HTML内容几乎相同，但DOM树是保存在内存中的树状解构，可以用js查询或者修改。

- 样式计算

当渲染引擎收到css文件后，会执行一个转换的操作，将css转换成stylesheet,然后进行标准话操作，所谓的标准话就是将所有值转换为渲染引擎可以理解、标准化计算的值。最后会计算出DOM树每个节点的样式属性，在计算的过程中需要遵循两个规则：

- - 继承规则： css子节点会继承父节点的某些属性，比如font-size、font-weight、color等，同时css的样式还有可能来自宇useragent样式，所谓的useragent样式是指浏览器自带的样式。

- - 样式层叠： 层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。

![Image text](/img/1252c6d3c1a51714606daa6bdad3a560.webp)


- 生成布局树

有些元素是不可见的，比如head以及display:none的元素在显示之前，会创建可见的布局树，主要完成了以下的操作。
- - 遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中。
- - 而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。

![Image text](/img/8e48b77dd48bdc509958e73b9935710e.webp)

- 布局计算

计算每个元素的几何坐标位置，并将这些信息保存在布局树中。

- 分层

有了布局树和计算完相关的布局后，还要进行分层，页面中有许多复杂的效果，比如3D转换、页面的滚动、或者使用z-index做z轴的排序，为了实现这些效果，渲染引擎会专门生成对应的图层，并生成一颗图层树（可以在chrome的开发者工具的layer查看相关的图层）。所以浏览器的页面实际被分成了很多图层，叠加在一起就得到了最后展示的效果。
![Image text](/img/e2c917edf5119cddfbec9481372f8fc0.webp)

但并不是每一个布局树的节点都有一个图层，生成图层得满足以下的条件

- - 拥有层叠上下文属性的元素会被提升为单独的一层。明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。

- - 需要剪裁（clip）的地方也会被创建为图层，如果出现滚动条，滚动条也会被提升为单独的层。

![Image text](/img/e8a7e60a2a08e05239456284d2aa4061.webp)


- 图层的绘制

渲染引擎会把图层分绘制拆封成很多小的指令，然后在把这些待绘制的列表拆分成很小的指令

![Image text](/img/40825a55214a7990bba6b9bec6e54108.webp)

- 栅格化（raster）操作

绘制列表是用来记录绘制顺序和绘制指令的列表，而实际上的绘制操作是由渲染引擎的合成线程来完成的。主线程会把绘制列表提交给合成线程。

![Image text](/img/46d33b6e5fca889ecbfab4516c80a441.webp)


> 视图是用户可见的区域，有的图层很大，通过视口只能看到图层的一小部分，在这种情况下，如果要绘制整个图层，就会产生大的开销，完全没有必要，所以合成线程会将图层划分成图快

![Image text](/img/bcc7f6983d5ece8e2dd716f431d0e052.webp)

然后合成线程会将这些图层绘制成图块，将视口附近的图快优先生成位图,生成位图的操作是由栅格化来执行的。所谓的栅格化是将图快转换为位图。图快是栅格化的最小单位，渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。

![Image text](/img/d8d77356211e12b47bb9f508e2db8520.webp)

通常栅格化的还会使用到gpu加速完成，使用gpu加速的栅格化叫快速栅格化，或者gpu栅格化。而gpu操作是在gpu进程中运行的，生成的位图被保存在 GPU 内存中。所以这就涉及到了跨进程的处理。

![Image text](/img/a8d954cd8e4722ee03d14afaa14c3987.webp)


- 合成显示

一旦所有的图快都完成了栅格化，合成线程就会生成一个“DrawQuad”绘制图层的指令，然后将该指令提交给浏览器进程的viz组件，然后浏览器进程会根据drawquad指令将页面内容绘制到内存中显示。
















