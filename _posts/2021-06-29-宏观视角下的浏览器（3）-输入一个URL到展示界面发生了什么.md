---
layout: post
title: 宏观视角下的浏览器（1）
subtitle: 输入一个URL会发生什么
date: 2020-12-09
author: Qi
header-img: img/404-bg.jpg
catalog: true
tags:
  - 浏览器
---

# 从浏览器的进程看输入URL发生了什么

- 浏览器进程接受到url后会处理输入的信息然后发送给网络进程
- 网络进程收到url后便会发起url请求
- 收到响应后网络进程收到响应头数据后解析并传给浏览器进程
- 浏览器进程收到网络进程的响应头数据后，发送“提交导航”信号到渲染进程
- 渲染进程收到“提交导航消息后”开始接受html数据，接受数据的方式是直接与网络进程建立数据管道
- 最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程‘已经准备好解析数据了“
- 浏览器进程收到渲染进程的”确认提交信号“后开始，开始移除旧的文档，显示新的界面

**用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。**

  ![Image text](/img/92d73c75308e50d5c06ad44612bcb45d.webp)

# 从输入 URL 到页面展示

**用户输入**

用户在输入后会判断输入的内容时搜索的内容还是请求的URL
- 如果是搜索的内容，那么地址栏会使用默认的搜索引擎，来合成带关键字的URL
- 如果判断输入的为符合规则的URL，那么地址栏会根据规则把这段内容加上协议合成完整的URL

当用户输入关键字并回车后意味着当前页面会被替换成新的界面，这个时候会给当前页面执行beforeUnload的事件机会，beforeUnload事件允许页面在退出时做一些数据清除的操作，还可以询问用户是否需要离开页面，比如当前页面还有未提交的表单，用户可以通过beforUnload事件取消导航，让浏览器不在进行后面的工作

**请求过程**

浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接

- 构建请求

浏览器构建请求行信息后准备发送网络请求

```

GET /index.html HTTP1.1

```

- 查找缓存

在浏览器发起请求之前会浏览器会在浏览器缓存中查找是否有要请求的文件，如果有缓存那么会拦截该请求，返回该资源的副本，如果缓存查找失败，那么就会进入网络请求。

这里说的缓存是指DNS缓存和http缓存，DNS 缓存主要就是在浏览器本地把对应的 IP 和域名关联起来，http缓存可以参考 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching


- 准备IP地址和端口

IP地址通过DNS解析获取，DNS解析首先会从缓存中查看是否解析过，如果没有那么会从本地操作系统的host中是否有映射，然后查看本地DNS服务器，如果本地的DNS服务器没有，本地的DNS请求根域名的DNS服务器，跟域名服务器会返回主域名服务器所在的IP，本地的DNS再根据主域名IP请求对应的名称服务器的IP地址，然后在请求对应的名称服务器根据映射表获取到目标的IP地址。

http的默认端口号是80，https的默认端口是443

如果协议是https，那么在这个过程还需要建立TLS连接，查看 https://juejin.cn/post/6906126429381984264

- 等待 TCP 队列

端口号和IP地址准备好了后还不能马上建立连接，Chrome有个机制，同一个域名下最大只能建立6个TCP连接，如果在同一个域名下发生10个请求，那么剩余的4个会进入等待状态，只有少于六个请求时才会建立TCP链接

- 建立TCP链接

TCP的连接主要是通过三次握手机制。建立连接时，客户端发送syn包（seq=j）到服务器，并进入SYN_SENT状态（半连接），等待服务器确认； 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN+ACK包，此时服务器进入SYN_RECV状态（半连接）。客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手，建立连接。

- 发送http请求

建立连接后，浏览器会向服务端发送请求行、请求头、请求体。

![Image text](/img/b8993c73f7b60feb9b8bd147545c47d7.webp)

**服务器端处理 HTTP 请求流程**

- 返回请求

一旦服务器处理请求完毕，那么首先会返回响应头，响应头包括协议版本和状态码，然后返回响应头和响应体。

![Image text](/img/3e30476a4bbda49fd7cd4fd0ea09f076.webp)

- 断开连接

一旦服务器发送数据完毕后就会断开连接，断开连接采用四次挥手的机制。
- - 断开连接时，主动方会向被动方发送一个带有FIN附加标记的报文段（FIN表示英文finish，主动方进入半关闭状态（FIN_WAIT_1）。
- - 被动方收到FIN标记的报文段后，不会马上断开连接，首先会发送一个ACK包给客户端，同时通知自己的应用程序对方要关闭连接了，进入close_wait状态。
- - 被动方向客户端发送一个带FIN的报文，进入close状态。
- - 主动方收到被动方发起的FIN报头后，进入time_wait状态，等待2MSL的时间进入到closed状态，释放套接字资源。释放前向被动方发起一个ack包，表示彻底释放。

如果浏览器或者服务器在其头信息中加入了：

```
Connection:Keep-Alive

```
那么TCP会保持连接，可以省去下次请求重新连接的时间，提升资源的加载速度

- 重定向

如果状态码返回的是301或者302，那么会进行重定向


![Image text](/img/1b49976aca2c700883d48d927f48986c.webp)






