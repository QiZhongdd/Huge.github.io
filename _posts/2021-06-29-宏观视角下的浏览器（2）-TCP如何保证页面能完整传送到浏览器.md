---
layout: post
title: 宏观视角下的浏览器（2）
subtitle: 如何保证页面文件能被完整送到浏览器
date: 2020-12-09
author: Qi
header-img: img/404-bg.jpg
catalog: true
tags:
  - 浏览器
---

# 一个数据包的“旅程”**

**IP将数据包送到目的主机主机**

IP包括IP的版本、源IP地址、目标IP地址、生成时间等信息，IP地址通过DNS解析获取得到。IP属于网络层。

**UDP将数据包送到对应的应用程序**

- UDP有个重要的信息是端口号，通过端口识别应用程序。
- 使用UDP传输数据包容易丢失
- 大文件会被拆分成很多小的数据包在不同的路由传输到接收端，但UDP并不知道如何对这些数据包进行重新组装。

> UDP属于用户数据包协议，属于传输层，UDP虽然可以校验数据包是否正确，但不具备重发机制，不保证数据的准确性，所以传输速度比TCP快，应用在不严格要求数据完整性的领域，如在线视频、互动游戏等。



**TCP将数据包完整的传送到应用程序**

- TCP能够对丢失的数据包进行重传机制
- TCP引入了数据包排序机制，用来保证把乱序的数据包拼接成一个数据包
- 和UDP一样，TCP头包含了目标端口和本机的端口号，同时还有数据包排序的序列号，用于拼接

  ![Image text](/img/WeChatecccc06602989528fe0be87967b1b7ac.png)


# TCP完整的生命周期

一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。

**通过三次握手建立连接**

- 建立连接时，客户端发送syn包（seq=j）到服务器，并进入SYN_SENT状态（半连接），等待服务器确认；
- 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN+ACK包，此时服务器进入SYN_RECV状态（半连接）。
- 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。


**传输阶段**

- 在传输阶段接收端接受到数据包后要发送确认数据包给发送方，如果发送方在一端时间内没有收到确认数据包，那么就会认为数据包丢失了，然后进行重传。
- 同时一个大的数据包在传输的时候需要拆分成多个数据包，到达接受房后根据数据包的序列号进行重写拼接

**TCP四次挥手断开连接**

- 断开连接时，主动方会向被动方发送一个带有FIN附加标记的报文段（FIN表示英文finish，主动方进入半关闭状态（FIN_WAIT_1）。
- 被动方收到FIN标记的报文段后，不会马上断开连接，首先会发送一个ACK包给客户端，同时通知自己的应用程序对方要关闭连接了，进入close_wait状态。
- 被动方向客户端发送一个带FIN的报文，进入close状态。
- 主动方收到被动方发起的FIN报头后，进入time_wait状态，等待2MSL的时间进入到closed状态，释放套接字资源。释放前向被动方发起一个ack包，表示彻底释放。



# 其他


- 为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？
第一，保证主动方发送的最后一个ACK报文能够到达被动方，因为这个ACK报文可能丢失，站在被动方的角度看来，我已经发送了FIN+ACK报文请求断开了，主动方还没有给我回应，应该是我发送的请求断开报文它没有收到，于是被动方又会重新发送一次，而主动方就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，主动方发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文


- HTTP 和 TCP 的关系

HTTP协议和TCP协议都是TCP/IP协议簇的子集。

HTTP协议属于应用层，TCP协议属于传输层，HTTP协议位于TCP协议的上层。

请求方要发送的数据包，在应用层加上HTTP头以后会交给传输层的TCP协议处理，应答方接收到的数据包，在传输层拆掉TCP头以后交给应用层的HTTP协议处理。建立 TCP 连接后会顺序收发数据，请求方和应答方都必须依据 HTTP 规范构建和解析HTTP报文。