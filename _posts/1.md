
js的装箱和拆箱：
所谓的装箱就是把js的原始数据类型值包装成对象，这个是js实现的，所以我们可以在基本数据类似上获取属性和方法。当装箱使用完毕后，会进行拆箱，拆箱就是恢复到原来的数据值。所以此时string instanceof String是false

原型链：
原型（prototype）是一个普通的对象，为构造函数的实例提供了共享的属性和方法。每个对象都有一个_proto_，指向构造函数的原型对象。所谓的原型链式是指获取一个实例对象的属性和方法是，会依次从实例本身、构造函数原型、构造函数的原型的原型一层一层向上查找，一直到Object.prototype。

由于js代码在执行时会被V8解析，这时会用不同的模板处理Js中的对象和函数，会用ObjectTemplate用来创建对象，返回值是ObjectTemplate的实例，FunctionTemplate用来创建函数，返回值是返FunctionTemplate的实例，PrototypeTemplate用来创建函数原型，返回值是ObjectTemplate的实例。所以Js中的对象原型可以这么判断，除了自定义构造函数实例外，所有的对象的原型都会指向Object.Prototype。自定义的构造函数的实例对应的是构造函数的原型。而函数的原型会指向Function.prototype

执行上下文栈：
函数在执行之前会做一些准备工作，这些准备工作称为执行上下文(EC)。Js脚本执行可能有多个函数，所以有多个执行上下文。js引擎会创建一个执行上下文栈（ESC）去管理这些上下文。脚本执行的时候首先会将全局执行上下文压入执行栈，当函数执行的时候会创建函数的执行上下文，并将函数的上下文压入执行栈，执行完后出栈

执行上下文包括变量对象（VO）、this、（作用域链）
变量对象用来存储定义的变量声明、形参、函数声明，在函数的上下文中，用AO表示VO,这是因为VO是不能访问的，在执行的时候VO才会被激活会变成AO，才能被上下文访问，AO分为两个阶段一个是在上下文创建阶段，会定义AO的属性，这个阶段首先会处理函数声明，然后才是变量声明，如果处理变量声明发下已经有申明的属性，则不会进行处理，这也是作用域提升函数优先于变量的原因。第二个阶段执行的时候会给AO的属性赋值

闭包：函数执行，会返回一个内部函数，内部函数会被外部变量所引用，并且内部函数的引用了外部函数的变量，这样就形成了一个闭包。
闭包的原理是作用域链的查找，当执行外部函数之前，初始化外部函数的执行上下、作用域链、AO，并将AO添加到作用域链中，AO包含了变量、函数声明、形参。当外部函数执行后，外部函数的执行上下文被销毁，但由于AO中的变量被内部函数引用，AO不会被销毁。当执行内部部函数时，也会初始化执行上下文、作用域链、内部函数的AO，将内部函数的AO添加到作用链顶端。执行上下文雅入栈中。执行的时候手先会从当前的AO中查找变量，没有找到就会用过作用域链去外层函数的AO中查找。

eventloop:
js分为同步任务和异步任务，js执行的时候同步任务在主线程中执行，异步任务会添加到异步队列，当主线程执行完同步任务后，调用栈会读取任务队列中的任务被主线程执行。浏览器时间循环的异步队列有两种，macro-task:(setTimeOut、setInterval、script、I/O、U/I渲染)
micro-task(promise.then、MutationObserver)。调用栈在读取任务执行首先读取排在最前的宏任务执行，如果当前执行的宏任务中有微任务，那么会将微任务添加到微任务队列中，待宏任务执行完后，会依次执行微任务队列中的任务，等到微任务队列清空后，再执行下一个宏任务，如此反复执行。所以eventloop就是调用栈不断的读取任务并清空的过程

node中的eventloop:
node执行过程：v8引擎解析js、解析后的代码调用NodeApi、它将不同的NodeApi交给不同的线程执行执行，形成一个evetloop，以异步的形式将执行结果返回给v8。，v8引擎将结果返回给用户。
libuv中的事件循环有以下阶段：
- updateTime:为了获取以下系统时间，以保证之后的timer有记时的标的，避免过多的系统调用影响性能
- timers:检查是否有timers，执行到期的类似setTimeout和setInterval的timer
- IO/CALLBACK:I/O时间的回调，比如网络i/o，文件i/o，当这些i/o动作结束时候调用
- idle/callback：这个阶段会处理以下内部的操作。
- 调用各平台提供的i/o多路复用接口，最多等到timeout时间，记录timeout自己的维护状态，在适当的条件下进行堵塞
- check阶段：执行setImmediate
- close/callback,关闭I/O的操作，比如文件描述符的关闭、连接断开等


在 node11 之前，因为每一个事件循环阶段完成后都会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行。

在 node11 之后，process.nextTick 被视为是微任务的一种，因此上述代码是先进入 check 阶段，执行一个 setImmediate 宏任务，然后执行其微任务队列，在执行下一个宏任务及其微任务队列


node执行顺序:process.nextTick->promise.then->宏任列->微队列，node11以后执行顺序跟浏览器一样。node11之前浏览器中会执行timer和immediate，然后在执行timer和immediate里面的微任务。

js中的对象和数组
js中的对象和数组的的索引会保存在栈中，值是保存在堆中。
js的对象就像一个字典，由一组属性和值构成。但由于字典是非线性的，查找效率会比较慢。V8为了提高查找效率，定义了常规属性properties和排序属性element。由数字定义的属性会存储在element中，其他属性会指向properties。V8为了提升properties的查找效率，当属性较少时，会存在对象自身中，被称为对象内属性，也被称为快属性。如果属性过多，其余的会存储在一个非线性的的数据结构中，被称为慢属性，降低了查找效率，这也是为什么当vue中的属性变多时，会变卡的原因。
js的数组能够方便快速查找，但删除和插入不是很友好。JSArray继承了JSObject,分为快数组和满数组，所谓的快数组时类似于数组的类，是一块连续的存储空间，可以直接用索引定位。能够动态的扩容和减容。而慢数组是一个哈希表，相比慢数组性能较差。当索引大于当前容量1024和快数组的容量扩容了三倍会变成慢数组，从而减少内存空间。当慢数组能够存储在快数组中，长度在smi之间且节省了50%的空间，那么会变成快数组


函数式编程：函数式编程（functional programming）是一种编程范式，它将计算机运算视为函数运算，并且避免使用程序状态以及易变对象。比起指令式编程，函数式编程关心数据的映射，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算。函数式编程有以下几个特点，函数是一等公民、没有副作用、不可更改状态、引用透明特点。

vue的异步任务队列
当vue的数据发生变化后，并不会马上对视图更新，首先会将watcher添加进缓冲队列。如果同一个watcher被触发多次，那么只会存入一次。这避免了不必要的重复计算和相同的dom操作。在nextTick中执行watcher，通知视图进行更新。nextTick首先会适配微任务，然后才是宏任务，这是因为在当前的事件循环中，微任务会优先于宏任务执行。适配顺序promise.then、messageChannel、setImmediate、setTimeout。

vue的Keep-alive
首先会拿到keep-alive下面的第一个子组件的name，判断当前name是否不在include或者在exclude中，那么会返回vnode。exclude的属性会比include的基本高
如果在include里面，那么会创建key值，key值由cid::tag组合。然后判断key值是否在缓存到数组中，如果在的话将key值从原来的地方删除并添加到尾部。如果不在的话直接添加到队列尾部。添加的时候如果超过了队列的限制大小，那么会将缓存队列的尾部的key值删除
将组件的keep-alive设置为true。组件加载的时候会根据createComponentInstance(第一次为undefined)和keep-alive判断是否需要执行crente和mount。如果keep-alive为true和createComponentInstance有值，那么就不会执行create和mout，直接patch,把缓存的对象直接插入目标元素中，完成视图更新
keep-alive运用了LRU缓存策略，LRU的核心策略是如果数据最近被访问，那么将来被访问的记录也比较高，一般由链表实现
首先会将新数据插入链表头部。
每当缓存命中，则将数据移到链表头部
链表满的时候，将链表尾部的数据丢弃


vue-router的原理是更新视图而不重新请求界面，分别有hash、history、abstract模式。
默认是hash模式，基于浏览器history api，采用window.addEventListner('hashchange)监听hash值的变化，如果是push则直接加到浏览器历史栈顶。如果是replcae，则直接替换浏览器历史栈顶

history模式，使用window.onpopstate对浏览器地址进行监听，对浏览器的history api的pushState和replcaeState进行封装，当方法调用时，会对历史栈顶进行修改。从而实现无需跳转url加载界面。但刷新界面会走后端路由，所以需要服务端进行兜底。

abstract不涉及浏览器的历史栈，一般用于服务端。
hash模式和history模式分别通过window.addEventListner对hashChange和popState监听，进行相对应的操作。可以通过go、forward、back访问浏览器历史栈顶。

vue的mixin和extend
vue的minxin和extend都是为了扩展组件的选项和配置。mixin能够接受多个对象，这些选项会被合并到最终选项，mixin钩子会在调用组件自身的钩子之前被调用。extend主要是为了扩展单文件的组件。两种都在mergeOptions进行实现。在调用mergeOptions时首先会规范化相关的选项，判断调用的是extend还是mixin,然后调用不同的mergeOptions。mixin会对注入对象的属性依次遍历赋值到对象的原型中，最后返回新的options。而extend是采用继承的方式继承相关的属性。

vue的template到render的过程
vue的模板编译过程大概如下：template->ast->render。这个过程是在compileToFunction下完成的。首先它会用正则表达式匹配模板字符串，解析到开始标签、闭合标签、文本都会采取不同的回调来构建Ast。构建完AST后还会对静态文件节点进行优化，就是打标签，后续的渲染如果识别到了标记，那么就不会重新渲染，这对运行时模板的优化有很大的作用。然后会调用generate，将ast转换为render字符串，调用new Function生成render函数

vue的计算属性和普通属性的区别：
computed的属性是数据层到视图层的数据转换成映射，计算属性是基于他们的依赖进行缓存的，只有在相关的属性发生变化时，他们才会改变。如果声明的计算属性计算量非常大的时候，而且访问量比较多，那么我们可以采用计算属性。


vue2的双向绑定：
vue2在实例化的时候首先会遍历data的属性，然后采用Object.defineProperty对相关属性进行监听。在模板首次渲染的时候会获取data中的属性，触发get,这时会通知Watcher添加相关的依赖，所谓的依赖就是Watcher本身，一个组件对应一个Watcher。当属性发生变化时，会触发set,这时会通知相关的依赖进行相关的视图更新。视图不是立即更新的，vue首先会将watcher添加进缓冲队列中，当同一个Watcher被触发多次后，那么只会添加一次，这节省了大量的计算的多次的dom更新。当所有的属性修改完后，会在nextTick中相关的事件队列。nextTick首先会适配promise.the、MessageChannel、setImmediate、setTimeOut。

vue2对数组方法的修改：vue2中，类似于pop、push、unshift、reverse、sort等api会对数组造成移位，所以在进行这些操作时，会触发多次的set。所以vue2对这些数组的方法进行了重写。首先会获取到数组原生的方法，列出需要修改的原生方法，如果是有新增项的方法，首先会对新增项进行Object.defineproperty。然后执行原生的方法，执行完了再手动通知视图更新。最后用Object.defineProperty对拷贝的原型链对象相关的属性进行重新定义



Object.defineProperty和Proxy的区别
1:Object.defineproperty只能劫持对象的属性，而Proxy直接代理对象。
2：Object.defineProperty对新增的属性不能监听，需要手动进行Observe，就是重新遍历对象，然后在调用Object.defineProperty对属性进行劫持。这也是Vue2对新增的属性需要调用Vue.set才能进行监听的原因。
3：Proxy的兼容性较差，目前没有完整的方案对Proxy的api进行polyfill;

vue3与vue2的对比
- 申明变量：vue3可以同过reactive声明响应式对象，也可以通过ref单独申明一个响应式的变量
- 增加了入口函数setUp，只有返回的方法和属性才能被视图引用，
- 生命周期发生了变更，beforeCreate和create有setup代替。其余的就名称发送了改变。
- 提供了tree-shaking，打包的时候去除了没用的模块，
- 更好的ts支持
- 响应式方式发生了改变，采用proxy。
- 重构了虚拟dom，保持兼容性，使dom脱离模板渲染,提升性能。

vue3：响应式的流程
- vue3初始化时会对相关的对象或者变量进行响应式处理，响应式处理采用的是proxy。
- 同时会执行一个effect函数，effect函数会接受render函数作为回调函数。effect函数会创建一个effect，会立即执行创建effect，执行的时候会把创建的effect添加进effectStack,添加完成后会执行render函数，render的时候会获取响应式数据的属性，从而触发get，调用track函数对依赖进行收集，所谓的依赖就是effect。
- 当属性发生修改时，会触发set,然后调用trigger，遍历effectStack，更新相关的视图

vuex:vuex是vue的状态器，使用时首先要用vue.use在beforeCreated阶段将store挂载在原型上。xuex主要有以下几种成分，store存储状态，mutaion修改状态，action进行异步操作，操作完后commit mutation修改状态。getters是state的衍生。与redux相比，vuex的状态改变后能立即更新视图，而redux不行，需要手动通知相关的订阅。同时vuex的state是可以直接修改的，而redux不行，每次调用reducer都得返回一个新的state去替换旧的state，所以vuex使用起来较简单，redux较繁琐

vue2:dom diff的过程
第一步：会在新的vnode和旧的vnode中添加开始指针和结束指针
第二步：会比较新的vnode和旧的vnode的开始节点是否相同
第三步：比较新的vnode和旧的vnode的结束节点是否相同
第四步：比较新的vnode的开始节点和旧的vnode的结束节点是否相同
第五步：比较新的vnode的结束节点和旧的vnode的开始节点是否相同
第六步：会在旧的vnode中查找是否有相同的节点
第七部：如果没有相同的节点，那么会在旧的vnode开始指针前插入一个新的节点
第八步：移动指针，继续比较，重复第二到第七的步骤
第九步：当找到相同的节点后，会进行递归，对子节点一层一层进行更细致的比较


对react fiber的理解：react fiber采用将任务采用分片式的方法处理，当运行完一段任务后，会查看有没有优先级更高的任务或者到期的任务，如果有那么就会立即执行，等到执行这些任务后会回到原来的任务继续执行。任务的分片依赖的是requestIdleCallback这个api,该api会在线程空闲的时候执行相关的任务，如果设置了timeout，那么到时的任务就会被强制执行。fiber的本质是个链表，包括chile、sibiling、return、stateNode，多个fIber会组成fiberTree，这是由于链表的特性，可以快速的找到打断的任务，然后重新执行。fiber更新组件分发reconliation阶段，和commit阶段。reconliation阶段是在render之前，这个阶段的任务是可以被打断的如果有优先级和到时的任务会执行较高的任务，当执行完优先级别较高的任务后会回到原来的任务重新执行，所以这个阶段的谁先执行由调度器决定,而commit阶段是在render之后对的，是不可以打断的，会依次执行。

react的调度过程
- 初始化调度之前先判读有没有同步任务，有则立即执行，如果没有则调用ensureRootIsScheduled进行初始化调度,调度的初始化首先会根据相关的规则进行调度
- - 判断有没有过期任务，有过期任务立即执行。
- - 没有新任务则立即退出调度
- - 有旧任务，则与旧任务比较优先级和过期时间。过期时间相同，旧任务优先级较高，则推出调度。过期时间不同，新任务的优先级较高会取消旧任务
- - 根据expirationTime执行不同的调度(scheduleSyncCallback或scheduleCallback), 最后将返回值设置到fiberRoot.callbackNode
- 在发起调度时会将及时任务和延时任务分别添加到taskQueue和timerQueue中，并设置相关的回调，及时任务为flushCallback,延时任务会设置定时器回调，触发后会将延时任务变成及时任务。然后会调用requestHostcallback,
创建MessageChannel，根据MessageChannel的特性，调用port.postMassage之后，会在宏任务里执行performWorkUntilDeadLine,在下一个事件循环执行调度
- 执行调度，循环执行任务队列taskQueue中的任务执行，并会检查当前的调度环境是否需要暂停和将控制权交给浏览器。
- 当检查到任务已经完成就会推出调度，如果检查到了timerQueue中有任务那么会在下一次事件循环中继续执行调度


setState 是同步还是异步
setState是同步渲染还是异步渲染取决于ReactFiberWorkLoop（fiber的构建循环）的执行上下文环境。是否同步调用取决于是否进入flushSyncCallbackQueue，在legacy模式下，并且执行上下文为空的时候调用setState会进入flushSyncCallbackQueue，异步任务或者原生事件中当前的执行上下文为空。如果是合成事件中的回调或者是concurrent 模式下是异步的

state是用来管理内部状态的，只能通过setState和forceUpdate改变状态更新视图。setState最终也会走forceUpdate。每个类组件都有一个updater对象用于管理state的变化。调用setState传入partialState时，会将partialState存入updater中的pendingState。此时updater又会调用emitUpdate来决定是否立即更新，判断条件简单来说是否有nextProps，或者updateQueue的isPending是否开启，updateQueue用于管理updater，如果updateQueue的isPending为true，那么
就将当前的update直接加入updateQueue的队列中，开启isPending的方式是可以自定义方法和生命周期函数，当这些方法执行完毕更新update，调用update的componentUpdate，判断组件的shouldComponentUpdate决定是否调用forceUpdate进行更新

react的useState和Clss中的state有什么区别
首先class中的state是immutable的，得通过setState去修改，会产生一个新的引用，可以通过this.state获取新的数据。
useState产生的数据也是immutable的，通过数组的第二个参数修改值。在下次渲染时，原来的值会产生一个新的引用。它的本质是闭包，最新的值跟着最新的渲染改变，但旧的渲染里，状态依然是旧值。两者的状态值都会挂载到FiberNode的memorizeState中。但两者的数据结构是不相同的，类组件直接把state挂载到到memorizeState中，而hook是以链表的形式保存的，memorizeState是链表的头部。

useEffect的以链表的形式挂载到FiberNode的updateQueue中，在初始化阶段函数会依次调用useEffect，依次挂载到fiberNode的updateQueue中，链表的节点属性有tag(用来标识依赖项有没有改变)，create(用户用useEffect传入的函数体)，destroy(上树函数执行后生成的用来清除副作用的函数)，deps(依赖选项表)，next(下一个节点)。组件渲染完成后，依次调用链表执行
在update阶段，同样会依次调用useEffect语句，此时会判断传入的依赖列表，与链表节点的Effect.deps中保存的是否一致（基本数据结构是否相同，引用是否相同），如果一致那么就会在effect.tag上标记NoHookEffect。组件渲染完成后就会进入useEffect的执行阶段function commonHookEffectList。首先会遍历链表，如果遇到tag为NoHookEffect的节点就会跳过，如果destroy为函数类型，那么就执行清除副作用的函数，执行create，并将执行结果保存到destroy中。所以整体的流程是先清除上一轮的 effect，然后再执行本轮的 effect







react的优化：
- 使用React.memo缓存组件，这样只有当传入组件的状态只发生变化时才会重新渲染，如果传入的只和上一次没有发生变化，则返回缓存的组件：
- 使用useMemo和useCallback缓存相关的计算结果。
- memo 仅针对函数组件，对于 class 组件，我们可以使用 PureComponent 或者是自己书写 shouldComponentUpdate 是否需要重新渲染当前组件。
- 避免使用内联对象，在 JSX 中创建一个内联对象的时候，每次重新渲染都会重新生成一个新的对象，如果这里还存在了引用关系的话，会大大增加性能损耗，所以尽量避免使用内联对象
- 避免使用匿名函数，匿名函数可以更加方便的对函数进行传参，但是同内联对象一样，每一次重新渲染都会生成一个新的函数，所以我们应该尽量避免使用内联函数。
- 运用react.lazy延迟加载不必要的组件

useState和useReducer都是关于状态值的提取和更新，从本质上来说没有什么区别，背后都是一套逻辑。可以看做useState是useReducer的简化版。





















v8的回收机制才用新生代和老生代结合的回收策略，所谓的新生代是指存活较短的变量，老生代是指存活较长的对象，类似于window|dom|web api等。
新手代采用scanvage算法，将新生代的内存空间分为from和to，from为正在使用的空间，to是闲置空间，当from块要满的时候，会将from中的对象推给to，这个时候to会变成from,from变成to.在这个过程中如果对象没有被引用，那么在这个过程对象会被回收掉。如果回收了两次对象还存在，那么这个对象就变成了老生代。老生代采用mark-swip和mark-compact的算法对对象进行回收，mark-sweap首先会对将要回收的变量进行标记，然后清除，这会造成内存不连续的情况，这是对内存的一种浪费。所以后来采用了mark-compact的算法，mark-compact首先会将不被垃圾回收的对象推到一边，然后将不被回收的边界签名的对象给清除掉。
垃圾回收的标记采用三色标记法，如果被GCRoot跟节点引用了，那么会被标记成黑色，黑色标记后面不能有白色的节点。没有被引用那么会被标记成白色，就会被回收。如果在回收的过程中，白色的节点被黑色标记所引用，那么就会变成灰色。
垃圾回收单独的一个线程，采用并行并发的策略，并且不会回收正在运行的对象，也不会影响主线程的执行。


性能优化的相关指标：FP首次绘制、FCP首次有内容的绘制、FMP首次有意义的绘制、TTFB首字节加载的时间、TTI可交互的时间，交互响应的时间不能大于100会有延迟感、LCP记录视窗内最大内容的绘制时间，会随着渲染时间变化而变化，在首次交互的时候会停止记录。FID首次交互延迟记录，在FCP到TTI用户交互的响应时间的延迟。TBT（Total Blocking Time）阻塞总时间，记录在 FCP 到 TTI 之间所有⻓任务的阻塞时间总和。CLS累计位移偏移，CLS 代表了⻚⾯的稳定，CLS 值⼀⼤的话会让⽤户觉得⻚⾯体验做的很差。

浏览器渲染的过程：浏览器在获取html内容后，会将html交给html parser生成domTree，css会交给css Parser生成cssOM,js会交给js引擎执行，js执行的时候可能导致dom tree重新生成，所以js会阻塞dom的解析。然后cssom和domTree结合，生成renderTree，这个过程会计算相关的布局和样式。生成rendeTree后，进入到paint阶段，在这个阶段会生成paint Rerord用来保存绘制顺序，因为dom是层级结构，没有绘制顺序的话就会造成绘制混轮。然后会将paint record和renderTree交给合成线程进行渲染，合成线程首先会将图层划分成多个图块进行栅格化，栅格化的图块会将图块暂存至gpu中，待所有的图块栅格化完成后，合成线程会收集相关的draw quads，所谓的draw quads就是相关的渲染信息。然后提交给浏览器进程，浏览器进程发送给GPU进行渲染

为什么栅格化线程会交给GPU而不是CPU
首先CPU和GPU都包含了DRAM、Control、ALU、Cahce，但两者的设计结构不一样，CPU包含了一大块的Control和Cache,Alu数量较少。大的缓存也可以降低延时。保存很多的数据放在缓存里面，当访问数据如果缓存里面存在，那么就可以直接从缓存里面获取。复杂的逻辑控制单元（Control）。当程序含有多个分支的时候，它通过提供分支预测的能力来降低延时。CPU 擅长各种复杂的逻辑运算，但不擅长数学运行。而GPU是基于大的吞吐量设计，有较多的alu和线程，但是缓存较少， 缓存的目的不是保存后面需要访问的数据的,而是为线程服务的，所以GPU擅长的是大规模并行计算。而栅格化是要处理多个图块的，并且做的事情都是一样的，比较适合采用GPU的并行计算。

重绘和重排
重排是指当dom或者布局发生改变，会将渲染流程重新执行一遍，对dom元素的读写也会造成重排
当元素的颜色发生变化，那么会对样式进行重新的计算和绘制。
重排和重绘都是比较消耗性能的，特别是重排，并且返回的重绘和重排会掉帧，造成页面卡顿，所以要尽量避免，可以采用css3硬件加速加transform、willchange、opacity，利用visibility代替display:hidden,避免使用css表达式，如果对dom有读写操作，那么要做到读写分离

性能优化
- Web 前端 80% 的响应时间花在图片、样式、脚本等资源下载上。所以需要减少http的请求，可以合理的合并js和css,使用雪碧图。
- 对资源进行压缩
- 图标使用cssIcon、雪碧图，不要缩放图像，
- 使用cdn获取资源，cdn不能过多，一边两到3个即可，过多会增加dns的解析时间
- 合理的使用缓存，比如浏览器缓存和本地缓存、serviceWorker
- 使用预加载,比如dns-预解析、预渲染、预加载
- 控制dom的数量
- 启动gzip传输


DNS解析流程：浏览器缓存-》本机操作系统-》本地域名解析服务系统-》跟域名服务器-》gTLD域名解析服务器-》nameServer服务器

CDN访问流程：
所谓的dns简称为内容分发网络，它的作用是在internet上加一层缓存层，将内容保存在离用户较近的网络边缘节点上，从而提高网络速度。它有以下几个特点，第一解决了网络第一公里的问题，所谓的第一公里就是用户从链路进入互联网，这一段的带宽较小，访问用户较多，引起阻塞，造成了网络延迟。第二个就是缓解了骨干网的压力。第三是缓解了出省的压力。第四个是解决了由于不同的运营商因为瓶颈造成的影响。
cdn的解析主要有以下几个步骤，在没有缓存的情况下，首先会向localDns发起域名解析请求，localDns会向根域名服务器发起请求，根域名服务器会返回授权服务器所在的地址，localDns会向域名授权服务器发起请求，域名授权服务器会返回域名记录，一般是CNAME,所谓的CNAME一般是指能根据一个域名获取到另一个域名。获取到域名记录后，智能DNS会根据自己的算法和策略去解析最适合用户cdn节点的ip返回给localDns，localDns会返回给用户，然后发起请求获取地址。简单点说就是通过修改dns解析，通过dns引导用户到cache服务器获取资源，加快请求速度。整个过程最重要的设备就是智能DNS,他能根据自己的算法和策略获取到最适合的cdn节点，同时能够与没给cdn节点保持联系，获取cdn的压力和相关的状态信息。

同源限制是指禁止文档或者脚本与另一个源进行交互和通信。只要端口、域名、协议不同都是跨域
跨域的解决方法；使用jsonp，jsonp的原理是通过script标签发起请求，然后处理相对应的回调请求。通过h5的postMessage、websocket，还有就是通过监听hashchange、CORS，CORS 需要浏览器和服务端同时支持通过这种方式发起的请求分为简单请求和复杂请求，简单请求有以下几种两种调解，通过get、post、head发起的请求。contentType有以下几种情况，分别是form/data、application/x-www-form-urlencode、text/plain。除了简单请求以外，其余的都是复杂请求。复杂请求首先会发现一次options请求判断服务端是否运行跨域请求。

特殊状态码：413：请求实体过大，超过了服务器能够处理请求的范围。一般是在上传文件的时候才会出现。可以配置nginx的client-max-body-size。

504：服务器作为网关或者代理服务器向上游发起请求时，未能及时响应.504一般都是和nginx的配置有关。比如nginx设置了超时时间，当在超时时间内没有收到请求就会给客户端返回504


http：在http0.9的时候http只能发送get请求，，并且只能响应Html字符串，服务器发送完毕后Tcp就会断开。在http1.0的时候，不仅可以传输文字，还可以传输图像、视频，二进制等，同时还引进了get、post、head请求。请求信息和响应信息也发生了改变，除了数据以为，还有头信息。但http1.0缺点是每个Tcp只能发送一个请求，发送完毕TCP就关闭，为了解决这问题，就出现了非标准字段connection:keep-alive。在http1.1的时候引入了持久链接，不要在标明connection:keep-alive，当客户端和服务端发现对方一段时间没有活动，就主动关闭。对于同一个域名大多数浏览器只支持连接6个持久化链接。并且Http1.1还引入了管道机制，所谓的管道机制就是只在同一个TCP连接里面能发送多个http请求，但是服务器还是按顺序响应，如果一个请求阻塞，后面的请求都会阻塞，这样就会造成对头堵塞。同时在http1.1一个tcp可以传输多个响应，为了区分数据包属于哪个响应，使用了content-length标识信息。http1.1还支持流式传输，通过设置Transfer-Encoding: chunked就可以支持流式传输。并且添加PUT、PATCH、HEAD、 OPTIONS、DELETE等请求方法。

htt2采用了二进制帧的形式对数据进行处理，头信息和数据体都是二进制，称为头信息帧和数据帧。同时http2采用多路复用的形式进行传输。所谓的多路复用是指多个请求共用一个TCP，将一个TCP分成若干个数据流，每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息，消息由二进制帧组成。帧是最小的通信单位，承载着特定类型的数据，例如http标头、消息负载等。来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装，这样就避免了对头堵塞。并且http2中，服务端可以在客户端某个请求后，主动推送其他资源。虽然 HTTP/2 解决了很多之前旧版本的问题，因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。当这个连接中出现了丢包的情况，整个 TCP 都要开始等待重传，也就导致了所有数据都被阻塞了。这个问题并不是它本身造成的，而是底层支撑的 TCP 协议的问题

http3使用了QUIC作为底层协议，而QUIC 基于 UDP 协议，在原来的功能上添加了一些新的功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等功能。
- QUIC的多路复用跟http2一样，同一条QUIC上有多个stream，来发送http请求，但是QUIC是基于UDP的，一个连接上的strem是没有依赖的，如果一个strem丢了包，并不会影响到其他strem的传输。并且QUIC在移动端的表现也会比TCP好，TCP是基于端口和IP识别连接的，在多变的网络环境下是很脆弱的，而QUIC是通过一个ID识别链接的，只要ID没变，就能很快链接上。
-ORTT 在 HTTP/2 中 http 链接需要 3RTT（TCP 握手 1RTT，TLS 中证书验证和秘钥交换需要 2RTT），就算将 TLS 升级到 1.3 或者考虑秘钥复用，HTTP/2 也需要 2RTT(TCP 握手 1RTT，获取 serviceConfig1RTT)。而 HTTP/3 首次连接只需要 1 RTT（获取 ServiceConfig），后面的连接更是只需 0 RTT，意味着客户端发给服务端的第一个包就带有请求数据
- 加密认证的报文
除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。
- 向前纠错机制
QUIC 协议有一个非常独特的特性，称为向前纠错 (Forward Error Correction，FEC)，每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间

TCP和UDP的区别
TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。
UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如：QQ 语音、 QQ 视频 、直播等等。

为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？
1. 为了保证 发送方 发送的最后一个 ACK 报文段能够到达 接收方。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 接收方 收不到对已发送的 FIN + ACK 报文段的确认。接收方会超时重传这个 FIN+ACK 报文段，而发送方就能在 2MSL 时间内收到这个重传的 FIN+ACK 报文段。接着 发送方 重传一次确认，重新启动 2MSL 计时器。最后，发送方 和 接收方 都正常进入到 CLOSED 状态。如果 发送方 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 接收方 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样，接收方 就无法按照正常步骤进入 CLOSED 状态。
2. 防止已失效的连接请求报文段出现在本连接中。发送方 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。

tcp:三次握手

TCP 客户端进程也是首先创建传输控制块 TCB。然后，在打算建立 TCP 连接时，向 B 发出连接请求报文段，这时首部中的同步位 SYN=1，同时选择一个初始序号 seq = x。TCP 规定，SYN 报文段（即 SYN = 1 的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。

第二次握手：B 收到连接请求报文后，如果同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时 TCP 服务端进程进入 SYN-RCVD（同步收到）状态。

第三次握手：TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack = y + 1，而自己的序号 seq = x + 1。这时 ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。




# TCP的四次挥手

第一次挥手：A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq = u（等于前面已传送过的数据的最后一个字节的序号加 1），这时 A 进入 FIN-WAIT-1（终止等待1）状态，等待 B 的确认。请注意：TCP 规定，FIN 报文段即使不携带数据，也将消耗掉一个序号。

第二次挥手：B 收到连接释放报文段后立即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v（等于 B 前面已经传送过的数据的最后一个字节的序号加1），然后 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP 服务端进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。A 收到来自 B 的确认后，就进入 FIN-WAIT-2(终止等待2)状态，等待 B 发出的连接释放报文段。

第三次挥手：若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。假定 B 的序号为 w（在半关闭状态，B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入 LAST-ACK(最后确认)状态，等待 A 的确认。

第四次挥手：A 在收到 B 的连接释放报文后，必须对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack = w + 1，而自己的序号 seq = u + 1（前面发送的 FIN 报文段要消耗一个序号）。然后进入 TIME-WAIT(时间等待) 状态。请注意，现在 TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL（MSL：最长报文段寿命）后，A 才能进入到 CLOSED 状态，然后撤销传输控制块，结束这次 TCP 连接。当然如果 B 一收到 A 的确认就进入 CLOSED 状态，然后撤销传输控制块。所以在释放连接时，B 结束 TCP 连接的时间要早于 A。

# 为什么连接是三次握手，断开是四次挥手。

主要原因是断开连接时，被动方收到FIN报文后，首先会发送一个ack包，等到应用程序处理完对应的任务后，才会发送一个fin的报文给主动端。而连接的时候服务端收到客户端的syn包后，会返回一个syn+ack的包。syn和ack是以前发送的，不是分块发送的。

# 滑动窗口
TCP 利用滑动窗口实现流量控制的机制。滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。

TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。

# https的过程

1、客户端发起请求，同时将客户端支持的TLS 协议版本号、加密规则、一个随机数（Client random），发送给服务器。
2、服务器上有安装好的认证证书（将服务器的私钥，通过权威机构 CA 认证后，生成的证书公钥和私钥）。
3、服务端确认双方使用的加密方法，使用 hash 算法签名证书后，将数字证书、一个服务器端生成的随机数（Server random），发送给客户端。
4、客户端验证证书。
使用 hash 检查证书是否被篡改。
验证失败，拒绝请求。
验证成功，生成新随机数（Premaster secret）。
5、使用证书公钥将随机值加密后传给服务端。
6、服务端用私钥解密消息内容，获得随机数（Premaster secret）。
7、服务端根据约定的加密方法，使用前面的三个随机数（Client random，Server random，Premaster secret）生成对话密钥（session key），并使用**对话密钥（session key）**加密传输内容，发送给客户端。
8、客户端使用同样的算法生成对话密钥（session key），并使用**对话密钥（session key）**对获取到的内容进行解密。
9、秘钥协商结束，客户端和服务器端通过对话密钥（session key） 作为对称加密 key，相互传输数据。

# 中间人攻击
- 本地请求被劫持(比如 DNS 劫持)，所有请求都会发送到中间人的服务器。
- 中间人服务器会将自己的证书发送给客户端，
- 客户端拿到中间人证书，创建随机数并用中间人证书公钥对其进行加密,然后发送给中间人。并且将传输内容根据随机数进行加密后进行传输。
- 中间人因为有了随机数，可以对请求内容解密。
- 中间人以客户端的请求内容向服务器发起请求。
- 中间人向服务器发起的请求是合法，服务器会返回响应内容。
- 中间人凭借与服务端构建的对称加密，可以对响应的内容进行解密。
- 中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输
- 客户端通过与中间人建立的对称加密算法对返回结果数据进行解密

由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。所以需要对证书进行合法的验证


















































