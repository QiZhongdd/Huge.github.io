---
layout: post
title: v8垃圾回收机制
subtitle: v8垃圾回收机制
date: 2020-06-29
author: Qi
header-img: img/404-bg.jpg
catalog: true
tags:
  - node
---

# 简介

Node 使用 JavaScript 在服务端操作大内存对象受到了一定的限制
(堆区)，在老生代中 64 位系统约为 1.4g,32 位系统为 0.7g,新生代中 64 位系统为 32m,32 位的为 16m。node —max-new-space-size 为新生代内层溢出，-max-old-space-size 为老生带内层溢出

# GC 回收的特点

- GC 回收是一个独立的线程
- GC 回收是按照固定的位置顺序进行回收的
- GC 回收时，回收的时候不能回收正在执行的对象,不能阻碍程序的运行。
- GC 回收是运行一会，回收一会，是穿插并且穿插在主线程不同的任务之间执行回收

一句话表示：小孩子尽管玩，到处丢东西大人收

# V8 垃圾回收的效率

全停顿：所谓的全停顿，是指主线程停下来进行 GC 回收，这样就会造成卡顿。所以 v8 内部还有并行、并发、增量等垃圾回收机制

- 并行是使用辅助线程进行进行垃圾回收
- 增量回收是指将标记工作分成多个阶段，穿插在不同任务之间执行。
- 并行回收是只在 js 执行任务的时候，辅助线程能够在后头进行回收
  ![Image text](/img/WechatIMG14.png)

# GC 回收的策略

V8 的垃圾回收策略主要基于分代式垃圾回收机制。V8 有两个垃圾回收器主垃圾回收器（Major GC）和副垃圾回收器（Minor GC）。分别对老生代和新生代进行回收。V8 内层分为新生代和老生代。

- 新生代，存活时间较短的变量
- 老生代，存活时间较长的对象，比如 window、DOM、WEB API,在一定条件下新生代对象也能转变成老生代

# Scavenge 算法

新生代的对象主要通过 Scaverage 算法进行垃圾回收，将空间一分为二，分别为正在使用的 from 空间和闲置的空间 to。分配时会先分配到 from,等到 from 快要满的时候它会将存活的对象推给 to，未存活的被释放，然后互换 from 和 to，这时候 from 编程了 to,to 编程了 from。等过了一段时间快要 from 快要满的时候，再次进行垃圾回收。如果对象进行了两次垃圾回收还存活，那么该对象会晋升为老生代，或者 to 的空间使用超过 25%了，那么它会将此时 to 空间的对象直接晋升到老生代，在老生代中进行回收。Scavenge 算法的缺点是只能占用一半的堆内存，典型的空间换取时间。由于新生代存活时间较短，所以也比较适合该方法。如果新生代爆栈了，那么就不进行 GC
![Image text](/img/WechatIMG12.png)

上图解释：

- 首先将内存变量 a 和 b 分配给 from，
- 等到 from 空间快满的时候，会将 a 推到 to 空间，b 会释放掉，因为 a 被引用了，b 没有。
- a 推到 to 后，会将 to 和 from 互换位置，to 编程 from，from 变成 to。
- 等到 from 空间快要满的时候回再次进行垃圾回收，如果 a 进行了两次垃圾回收，a 还存在，那么 a 会晋升为老生代。

# Mark-Sweep & Mark-compact

Mark-Sweep 和 Mark-compact 是老生代进行垃圾回收的算法，Mark-Sweep 首先将需要进行垃圾回收的变量进行标记，然后清除，但是标记清除会出现内存不联系的情况，这是对内存的一种浪费。这时候就使用 Mark-compact 方法，Mark-compact 方法是根据 Mark-sweep 方法演变而来的，它首先将不需要清除的对象统一推到最右边，然后将前面的需要进行垃圾回收的变量清除掉

![Image text](/img/WechatIMG13.png)

# GC 如何标记对象

垃圾回收是通过 GCRoot(全局的 window 对象、文档 DOM 树、存放栈上对象)标记存活对象和非存活对象，如果能在 GCRoot 中遍历得到对象那么就是存活对象，不能遍历得到就是非存活对象，会被回收。

**V8 标记对象时，采用的是三色标记法，也被称为强三色不变性**

- 黑色的标记对象表示被 GC root 引用到了，而且该节点的子节点已经标记完成，黑色标记对象后面不能有白色节点。
- 白色节点表示没有被 GC root 引用，如果本轮遍历结束后没有被引用，还是白色，那么会被回收掉。
- 灰色节点，在执行的时候，如果有个白色节点被黑色节点引用了，写屏障机智白色节点会变成灰色节点，不会被垃圾回收。

![Image text](/img/WechatIMG1000.png)
在图中 window.a.b.c={},对 a,b,c，d 扫描完一遍后，a,b,c 都是黑色,d 是白色，如果此时执行 window.a.b=d，写屏障机制会将 d 强制变成灰色。c 会变成白色。待遍历结束后白色的对象会被回收。在 V8 中，每次执行如 window.a.b = value 的写操作之后，V8 会插入
写屏障代码，强制将 value 这块内存标记为灰色。
