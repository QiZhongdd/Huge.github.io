---
layout: post
title: 时间复杂度和空间复杂度
subtitle: 时间复杂度和空间复杂度
date: 2020-04-28
author: Qi
header-img: img/404-bg.jpg
catalog: true
tags:
  - 算法
---

# 1.算法效率评估的标准：时间复杂度和空间复杂度

- 时间复杂度：评估程序所需要的时间，可以估算出程序对处理器的使用程度
- 空间复杂度：评估程序所需要的内存，可以估算出程序对内存的使用程度

# 2.时间复杂度

**时间频度**

一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为 T(n)。

**时间复杂度**

前面提到的时间频度 T(n)中，n 称为问题的规模，当 n 不断变化时，时间频度 T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。一般情况下，算法中基本操作重复执行的次数是问题规模 n 的某个函数，用 T(n)表示，若有某个辅助函数 f(n)，使得当 n 趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称 f(n)是 T(n)的同数量级函数，记作 T(n)=O(f(n))，它称为算法的渐进时间复杂度，简称时间复杂度。因为渐进时间复杂度用大 O 表示，也称为大 O 表示法。

**推倒时间复杂度的规则**

- 如果运行时间为常量级，则用常数 1 表示
- 只保留时间函数中的最高阶项
- 如果最高阶项存在，则省去最高阶项前面的系数

**线性阶**

> 线性阶主要要分析循环结构的运行情况,下面代码题 T(n)最高阶项为 3n，省去系数 3，则转化的时间复杂度为：T(n)=O(n)。

```
for(int i=0; i<n; i++){
console.log("等待1分钟");
console.log("等待1分钟");
console.log("等待1分钟");
}
```

![](https://user-gold-cdn.xitu.io/2020/4/30/171c8cbce3454daf?w=878&h=516&f=png&s=122379)

**对数阶**

> 下面代码体 T(n) = 2logn,省去系数 2，所以时间复杂度为 T(n) =O(logn)。

```
var number=1;
while(number<n){
number=number*2;
console.log(number)
//时间复杂度为O(1)的算法
}
```

![](https://user-gold-cdn.xitu.io/2020/4/30/171c8d9ff94eafcf?w=854&h=498&f=png&s=77624)

**常数量级**

> 下面代码体 T(n) = 2， 只有常数量级，则转化的时间复杂度为：T(n) =O(1)。

```
number=number*2;
console.log(number)
```

![](https://user-gold-cdn.xitu.io/2020/4/30/171c8dc3c64787a6?w=812&h=488&f=png&s=72619)

**平方阶**
内层循环的时间复杂度在讲到线性阶时就已经得知是 O(n)，现在经过外层循环 n 次，那么这段算法的时间复杂度则为 O(n²)。

```
for(int i=0;i<n;i++){
      for(int j=0;j<n;i++){
         //复杂度为O(1)的算法
         ...
      }
  }
```

**其他复杂度**

> 除了常数阶、线性阶、平方阶、对数阶，还有如下时间复杂度：f(n)=nlogn 时，时间复杂度为 O(nlogn)，可以称为 nlogn 阶。f(n)=n³ 时，时间复杂度为 O(n³)，可以称为立方阶。f(n)=2ⁿ 时，时间复杂度为 O(2ⁿ)，可以称为指数阶。f(n)=n!时，时间复杂度为 O(n!)，可以称为阶乘阶。f(n)=(√n 时，时间复杂度为 O(√n)，可以称为平方根阶。
> **时间复杂度的比较** 4.复杂度的比较
> 下面将算法中常见的 f(n)值根据几种典型的数量级来列成一张表，根据这种表，我们来看看各种算法复杂度的差异。

![](https://user-gold-cdn.xitu.io/2020/4/30/171c8e815d3443f7?w=1066&h=506&f=png&s=33499)

从上表可以看出，O(n)、O(logn)、O(√n )、O(nlogn )随着 n 的增加，复杂度提升不大，因此这些复杂度属于效率高的算法，反观 O(2ⁿ)和 O(n!)当 n 增加到 50 时，复杂度就突破十位数了，这种效率极差的复杂度最好不要出现在程序中，因此在动手编程时要评估所写算法的最坏情况的复杂度。下面给出一个更加直观的图：

![](https://user-gold-cdn.xitu.io/2020/4/30/171c8e7c7e5cf3e5?w=846&h=442&f=png&s=162189)
其中 x 轴代表 n 值，y 轴代表 T(n)值（时间复杂度）。T(n)值随着 n 的值的变化而变化，其中可以看出 O(n!)和 O(2ⁿ)随着 n 值的增大，它们的 T(n)值上升幅度非常大，而 O(logn)、O(n)、O(nlogn)随着 n 值的增大，T(n)值上升幅度则很小。常用的时间复杂度按照耗费的时间从小到大依次是：

> O(1)<O(logn)<O(n)<O(nlogn)<O(n²)<O(n³)<O(2ⁿ)<O(n!)

# 3.空间复杂度

> 内存空间是有限的，在时间复杂度相同的情况下，算法占用的内存空间 自然是越小越好。如何描述一个算法占用的内存空间的大小呢？这就用到了算法的 另一个重要指标——空间复杂度（space complexity）。 和时间复杂度类似，空间复杂度是对一个算法在运行过程中临时占用存储空间 大小的量度，它同样使用了大 O 表示法。常见的空间复杂度有下面几种情形。

**常量空间**

> 当算法的存储空间大小固定，和输入规模没有直接的关系时，空间复杂度记 作 O(1)。例如下面这段程序：

```
 function(){
    var n = 2;
 }
```

**线性空间**

> 当算法分配的空间是一个线性的集合,比如数组和对象，并且集合大小和输入规模 n 成 正比时，空间复杂度记作 O(n)。

```
 function a(){
    var arr= [2,3];
 }
```

**二维空间**

> 当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模 n 成正比时，空间复杂度记作 O(n2)。

```
 function a(){
    var arr= [[2,222],[3,333]];
 }
```

**递归空间**

> 递归是一个比较特殊的场景。虽然递归代码中并没有显式地声明变量或集合， 但是计算机在执行程序时，会专门分配一块内存，用来存储“方法调用栈”。 “方法调用栈”包括进栈和出栈两个行为。

```
 function a(i){
    if(i<4){
        i++
         a()
    }else{
        return
    }
 }
```

> 执行递归操作所需要的内存空 间和递归的深度成正比。纯粹的递归操作的空间复杂度也是线性的，如果递归的深 度是 n，那么空间复杂度就是 O(n)。

# 4.时间复杂度与空间复杂度的取舍

人们之所以花大力气去评估算法的时间复杂度和空间复杂度，其根本原因是计 算机的运算速度和空间资源是有限的。对于计算机系统来说也是如此。虽然目前计算机的 CPU 处理速度不断飙升，内存 和硬盘空间也越来越大，但是面对庞大而复杂的数据和业务，我们仍然要精打细 算，选择最有效的利用方式。 但是，正所谓鱼和熊掌不可兼得。很多时候，我们不得不在时间复杂度和空间 复杂度之间进行取舍。
**在绝大多数时候，时间复杂度更为重要一些，我们宁可多分配一些内存空间， 也要提升程序的执行速度。**

# 参考

- 小灰的算法之旅
- https://juejin.im/post/58d15f1044d90400691834d4
