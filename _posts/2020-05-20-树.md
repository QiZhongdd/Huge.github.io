---
layout: post
title: 树
subtitle: 树
date: 2020-05-20
author: Qi
header-img: img/404-bg.jpg
catalog: true
tags:
  - 数据结构
---

# 树的基本概念

- 位于树顶部的节点叫跟节点，它没有父元素
- 节点分为内部节点和外部节点，有子节点的称为内部节点，没有子节点的称为外部节点，子节点也称为外部节点
- 节点的一个属性是深度，有多少个祖先节点就有多深

# 二叉树和二叉搜索树

> 二叉树只有左右两个节点，二叉搜索树是二叉搜索树的一种，它的左节点比根节点小，右节点比根节点大。

**创建二叉搜索树的结构**

```
function TreeNode(key){
  this.left=null;
  this.key=key;
  this.right=null
}
var root=null//根节点
```

**二插搜索树的添加**

- 首先判断根节点是否为空，如果为空，那么添加的就是根节点
- 然后判断根节点的健是否大于加入节点的健
- 如果小于排左边，查看位置是否占用，如果占用使用递归，知道找到没有占用的位置
- 如果大于排右边查看位置是否占用，如果占用使用递归，知道找到没有占用的位置

```
function insert(key){
  let node=new TreeNode(key);
  if(root=null){
    root=treeNode
  }else{
    insertNode(root,node)
  }
}
function insertNode(root,node){
  if(root.key<node.key){
    if(root.left===null){
      root.left=node
    }else{
      insertNode(root.left,node)
    }
  }else{
    if(root.right===null){
      root.right=node;
    }else{
      insertNode(root.right,node)
    }
  }
}

```

**二插树的遍历**

- 中序遍历,所谓的中序遍历就是从最小的节点按顺序排访到最大的节点，相当于给二叉搜索树排序

```
//callback用来执行排访节点后的回调函数
//node===null条件是停止递归的关键
//调用递归函数访问左边的节点，然后调用递归函数访问右边的节点。
function inOrderTraverse=function(callback){
  inOrderTraverseNode(root,callback)
}
var inOrderTraverseNode(node,callback){
 if(node===null)return;
 inOrderTraverseNode(node.left,callback)
 callback(node)
 inOrderTraverseNode(node.right,callback)
}
```

- 中序遍历，中序遍历是跟节点优先于子节点执行，先序遍历的一种应用就是打印结构化的文档

```
this.prevTravel=function(callback){
  preTravelNode(root,callback)
}
var preTravelNode=function(node,callback){
  if(node===null)return;
  callback(node);
  preTravelNode(node.left)
  preTravelNode(node.right)
}
```

- 后序遍历就是优先访问后代节点，最后访问根节点

```
this.afterTravel=function(callback){
  afterTravelNode(root)
}
afterTravelNode(node,callback){
  afterTravelNode(node.left)
  afterTravelNode(node.right)
  callback(node)
}
```

**二叉树的搜索**
在二叉树中常用的搜索是搜索最大值、最小值和特定对的值

- 最小值及最深层次左节点的值

```
findMinNode(root)
function findMinNode(node){
  if(node){
    if(node.left===null)return node;
    findMinNode(node.left)
  }
  return null;
}
```

- 最大值及最深层次右节点的值

```
findMaxNode(root)
function findMaxNode(node){
  if(node){
    if(node.right===null)return node;
    findMinNode(node.right)
  }
  return null;
}
```

- 搜索一个特定的值

```
searchNode(key,root)
function searchNode(key,node){
  if(node){
    if(key===node.key){
      return true
    }else if(key<node.key){
      searchNode(key,node.left)
    }else if(key>node.key){
      searchNode(key,node.right)
    }
  }
  return false
}
```

**二叉树的删除**
二叉树的删除首先要找到对应的值，然后将值设置为 null,并且返回该 node(null)，使父元素的指正指向 null

```
function removeNode(node,key){
  if(node===null)return null;
  if(node.key>key){
    node.right=removeNode(node.right,key)
    return node;
  }else if(node.key<key){
    node.left=removeNode(node.left,key)
    return node
  }else{
    //没有子节点
    if(node.left===null&&node.right===null){
      node=null;
      return node;
    }
    //只有一个子节点
    if(node.left===null){
      node=node.right;
      return node
    }else if(node.right===null){
      node=node.left;
      return node;
    }
    //左右两个节点都存在，找到右树的最小值，将右树的最小值作为改节点的值，然后删除右树的最小的值
    var aux=findMinNode(node.right);
    node.key=aux.key;
    node.right=removeNode(node.right,aux.key)
    return node;

  }
}
```
