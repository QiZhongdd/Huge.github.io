---
layout: post
title: 线程与进程
subtitle: 线程与进程
date: 2020-07-10
author: Qi
header-img: img/404-bg.jpg
catalog: true
tags:
  - 计算机基础知识
---

# 进程

进程的目的就是担当分配资源（CPU 时间、内存）的实体，cpu 时间和内存由系统统一分配。进程可以看做用来启动程序的实体，他的主要目的是将程序交给程序去执行

- cpu 在同一时间只能处理一个指令。多进程并发依赖 cpu 时间的分配，系统首先会把 cpu 时间进行分片，每个分片对应不同的程序，进程在时间片轮流执行，运行完后就挂起。优先级高的cpu时间会分配多一点，优先级低的少一些。比如下图cpu运行完1号进程后会把cpu回收，然后运行二号进程，类似于http2的多路复用

![Image text](/img/1624602245400.jpg)

- 操作系统有一个 loader(装载程序)，操作系统启动后会 loader 会被引导程序添加进内存的绝对地址，然后 loader 会将 cpu 添加进内存地址，最后再给启动的进程分配一个固定内存，内存由操作系统统一分配。当进程内存不够后，它会去操作系统请求内存，如果系统认为还有内存，那么就分配内存给进程。

# 线程

线程是操作系统能够进行运算调度的最小单位，线程必须依赖于进程，一个进程可以有多个线程，进程中有主线程，如果主线程退出，那么进程也会退出.在启动一个程序后，需要执行多个任务，比如qq音乐需要播放音乐、并且同时连接网络，首发数据，这时就交由线程处理。

# 进程和线程在操作系统中的设计

- 以多进程的形式执行多个任务
- 以多线程的形式将单个任务分成不同的部分执行
- 提供调解机制，防止进程和线程之间的调度发生 冲突，同时允许进程和线程之间共享资源。常见的冲突有以下几种：
- - 两个进程或者线程同时读写文件，造成文件混乱
- - AB 两个进程，A 对共享内存进行写入操作，B 对共享内存读取

**解决冲突的方式有两种，一种是对资源进行独享，另一种是加锁**，加锁是指对操作资源或者对象的函数加锁，这也就是所谓的原子操作。加锁后其他线程不能进行操作，要等到该线程释放后才能进行操作。第二种对资源的独享比如串口（USB），一个串口只能被一个进程占有。

# 进程与线程之间的资源共享

**进程包含的内容**
进程包含的内容包括以下几种：

- 代码，进程运行的相关代码
- 数据,进程运行代码操作的对象、变量
- 文件，是指打开的文件和网络
- 寄存器，用来存放指令、运算数据、代码执行的顺序等。随着代码的执行一直在变化
- 函数栈，指函数之间的调用栈。
- 线程，依附在该进程上的线程

![Image text](/img/WeChat0a249bc71cc20200dc3eccf4b75b8c30.png)

**进程运行任务的模式步骤**

- 运行多个任务，要依赖父子进程的模式
- 启动任务，首先会创建一个主进程，由这个主进程对子进程进行管理
- 主进程运行会完全拷贝自身生成子进程，子进程也可以对自身进行复制。这是 fork 模式(分叉)，多进程运行多任务的时候采用该模式。
- 另外一种是 exec 模式，例如有程序一和二，首先程序一运行的时候创建进程一，然后进程一把程序二运行起来，程序二会创建一个进程二，这个时候进程一就是进程二的主进程
- 主进程与子进程不会发生资源的冲突，有主进程统一分配，子进程是依赖于父进程的。

进程在进行 fork 的时候回把所有的资源都拷贝下来，并且在进行子进程的切换时会消耗大量的资源。所有后来就出现了多线程进程。






**多线程进程**

- 线程必须依赖于进程，代码、数据、文件还是保存在进程中供多个线程共享，但寄存器和栈由线程个自保管。所以多线程进程在运行多任务 fork 时，只需 fork 寄存器和函数栈就行。
  ![Image text](/img/WechatIMG78.png)

  # pm2 拉起多个进程的模式

- pm2 运行时创建主进程
- 主进程会 fork 自身生成子进程，生成子进程的数有 cpu 内核数或者设置决定，目的是为了最大限度的使用 cpu 的资源
- fork 后由于子进程与主进程有相同的代码，所以代码中要判断是否是子进程，如果是主进程就 fork 自身，子进程就运行任务
- 主进程不执行任务，它的作用是对子进程进行监控。

```
 var cluster = require('cluster');//操作系统的集群
 var numCPUs = require('os').cpus().length;//获取cpu内核信息
if (cluster.isMaster) {//判断是否主进程
for (var i = 0; i < numCPUs; i++) {
var worker = cluster.fork();//主进程拷贝自身生成子进程，拷贝完后主进程不会退出
}
} else {
require("./app.js");//子进程运行任务
}

```

**协程**

协程是用户态的轻量级线程，一般是由第三方的库提供，它无法调用核资源


> IO密集型的压力主要是服务端，主要是涉及到文件系统和网络IO，因为要涉及到硬件的交互，凡是涉及到硬件的交互都可能会有性能问题，所以需要处理高并发，需要运用缓存去优化。cpu密集型的压力主要是客户端。
